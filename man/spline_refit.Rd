% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/spline_refit.R
\name{spline_refit}
\alias{spline_refit}
\title{\code{spline_refit()}}
\usage{
spline_refit(mod, to_spline = "all", df = 5, spline_type = "ns")
}
\arguments{
\item{mod}{A model object that inherits from \code{lm} or \code{glm}.}

\item{to_spline}{The terms to refit as spline terms (\code{"all"} or a
character vector).}

\item{df}{Degrees of freedom for the spline term(s) (either a single value,
in which case all spline terms will be fit with that df, or a numeric vector
with the same length as \code{to_spline}).}

\item{spline_type}{Use cubic or natural (restricted cubic) splines?
Must be either \code{"bs"} or \code{"ns"}.}
}
\value{
The updated model (invisibly), plus output in the console.
}
\description{
\code{spline_refit()} takes an \code{lm} or \code{glm} model
object (generally containing linear terms) and refits it with nonlinear
spline terms. The function returns the refit model (invisibly) and prints
console output with AIC and BIC values from the original and new models
for comparison.
}
\details{
If the user leaves the \code{to_spline} argument at its default
value, \code{"all"}, the function tries to identify main effect terms that
are specified as linear in the model and refit them as splines.
If \code{to_spline} is \code{"all"}, then the number given as the \code{df}
argument applies to all new spline terms. Alternatively, the user can
specify a set of linear main effects to refit as splines via the
\code{to_spline} argument. In that case, the user can set \code{df} to be a
single value (which will serve as the df of all new spline terms), or the
user can pass a vector of df values to \code{df}, with each corresponding to
a desired spline term.

Currently, the function will only refit with splines terms that can be
identified as straightforward main effects of continuous variables:
It won't refit interaction terms (if created via \code{y ~ x*z} or
\code{y ~ x:z}), terms for binary predictors or factor variables,
terms created with \code{I()}, or any other terms containing \code{:}
(signaling an interaction) or parentheses (usually signaling an on-the-fly
variable computation or rescale). The primary limitation of this is that if
a user wants to fit a spline term to a predictor that has been put on the
log scale, they must create the logged version of the variable in the data
set underlying the model and use that variable directly in the model.
}
\examples{
m <- lm(mpg ~ hp, mtcars)
spline_refit(mod = m, to_spline = 'all', df = 4, spline_type = 'ns')

# Function identifies the binary predictor (am) and the
# interaction term and only refits drat with splines:
m <- glm(vs ~ drat*am, mtcars, family = 'binomial')
spline_refit(m, 'all', 4, 'ns')

# To refit the logged wt term in the model below with splines,
# one would need to compute log(wt) in the data set and use the
# corresponding variable in the model
m <- lm(log(mpg) ~ hp + wt + log(wt), mtcars)
spline_refit(m, c('hp', 'wt'), 4, 'bs')

# The updated model is returned invisibly:
m <- glm(vs ~ drat*am, mtcars, family = 'binomial')
updated_mod <- spline_refit(m, 'all', 4, 'ns')
ggeffects::ggpredict(updated_mod, terms = c('drat', 'am')) |>
  plot()

}
